/*
 Copyright (C) 2012 jaseg <s@jaseg.de>

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 version 3 as published by the Free Software Foundation.
 */

#include <avr/io.h>
#include <util/delay.h>

void ${modulevar("buf")}_swapBuffers(void){
	uint8_t* tmp = ${modulevar("internalBuffer")};
	${modulevar("internalBuffer")} = ${modulevar("externalBuffer")};
	${modulevar("externalBuffer")} = tmp;
}

void ${module_callback("setLED", "BB")} (uint16_t argsize, uint8_t* args){
	//args: num, val
	uint8_t num = args[0];
	uint8_t val = args[1];
	if(num<32){
		frameBuffer[num>>3] &= ~(1<<(num&7));
		if(val)
			frameBuffer[num>>3] |= 1<<(num&7);
	}
}

//The DDRs of the led matrix outputs are set in the mux loop.
void ${loop_function} (){
	static uint8_t row = 2;	//selects the currently active "row" of the matrix. On the
							//protoboards I make, this more or less corresponds to physical traces.
	uint8_t ddr = frameBuffer[i];
	uint8_t port = ~ddr;
	port |= row;
	ddr |= row;
	PORT${member["port"]} = port;
	DDR${member["ddr"]} = ddr;
	row <<= 1;
	if(row == 0)
		row = 2;
}

//this scary construct is in place to make the compiler happy. if you know a better way, feel free to improve.
uint8_t ${modulevar("buf")}[7];
uint8_t ${modulevar("buf2")}[7];
uint8_t* ${modulevar("internalBuffer")} = ${modulevar("buf")};
uint8_t* ${modulevar("externalBuffer")} = ${modulevar("buf2")};
//generate accessors
//CAUTION! Despite the c comment, this template command gets executed!
//${modulevar("externalBuffer", "uint8_t", "7B", 7)}

