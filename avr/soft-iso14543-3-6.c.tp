
#ifndef _SOFT_ISO14543_3_6_
#define _SOFT_ISO14543_3_6_

//Structure of a iso14543-3-6 TP1 standard, extended and poll frame
typedef struct {
	unsigned char seqnum;
	//I kind of hate the person concocting this control field. On the other hand, it is probably the result of the work (I won't say collaboration) of a number of persons equal to the population of a small country.
	struct ctrl {				//Control field, always the first byte
		unsigned char ft:1;			//Frame type: 0 - extended/poll; 1 - standard
		unsigned char poll: 1;		//Poll frame - 1; otherwise 0
									//ft/poll are used in ack frames as follows: ack/busy 11, nack/nack+busy 00
		unsigned char r: 1;			//Repeat flag: 0 - repeated frame/ack frame; 1 - not repeated frame/poll frame
		unsigned char ack: 1;		//Ack frame - 0; otherwise 1
		unsigned char priority: 2;	//Priority: system/poll 0, urgent 2, normal 1, low 3
									// if this is an ack frame: ack/nack 3, busy/nack+busy 0
		unsigned char _: 2;			//Padding, always 00
	}; //1 byte
	struct ctrle {				//Extended control field (only present in -- you guessed it, extended frames)
		unsigned char at:1;			//Destination address type: physical/individual - 0; group - 1
		unsigned char hops:3;		//Hop count
		unsigned char eff:4;		//Extended frame format: default 0, LTE-HEE extended address type 01xx
	}; //1 byte
	union sa {					//Source address
		unsigned int i16;
		struct phy {				//Physical address
			unsigned char area:4;		//Area
			unsigned char line:4;		//Line
			unsigned char device;		//Device
		};
	}; //1 word
	union da {					//Destination address
		unsigned int group;			//Group/poll group address
		struct phy {				//Physical address
			unsigned char area:4;		//Area
			unsigned char line:4;		//Line
			unsigned char device;		//Device
		};
	}; //1 word
	union aux {					//Various flags
		struct std {				//Standard frame
			unsigned char at:1;			//Destination address type: physical/individual - 0; group - 1
			unsigned char hops:3;		//Hop count
			unsigned char len:4;		//Payload length
		};
		struct ext {				//Extended frame
			unsigned char len;			//Payload length (0xFF is an escape code)
		};
		struct poll {				//Poll frame
			unsigned char _:4;			//Padding (0000)
			unsigned char len:4;		//Number of poll responses expected
		};
	}; //1 byte
	unsigned char payload[255];
	unsigned char checksum;		//xor all bytes of the frame, invert.
} iso14543_3_6_frame;

#endif//_SOFT_ISO14543_3_6_

${modulevar("frame", "iso14543_3_6_frame", "BBHHB255sB", set_action=modulevar("frame")+"_set_action");

unsigned char ${modulevar("status")} = 0;
unsigned char ${modulevar("checksum")} = 0;

void ${init_function()} (void){
	DDR${member["tx"]["port"]} |= (1<<${member["tx"]["pin"]});
	//set up pin change interrupt
}

//add pin change interrupt vector

//XXX This module uses pin change interrupts since the pulses it tries to detect are only 34Âµs long (@16MHz ~= 512 cycles)
//XXX This module uses one 16-bit timer
//The timer is clocked with a 16934400Hz system clock overflows every 588 cycles. A bit is over every 1764 cycles.
//The error of this timing is less than 1% compared to a 9600Bd reference.

//Returns 0 on success, other stuff when an error occurs.
char iso14543_send(unsigned char data){
	${modulevar("checksum")} ^= data;
	for(unsigned char i = 0; i<8; i++){
		
		unsigned char nd = data << 1;
		if(nd < data){ //ft bit set
			// i.e. (data * 2) mod 256 < data
			// unsigned char => 0 < data < 256
			// data < 128:
			//   data * 2 < data => false
			// data >= 128:
			//   data * 2 - 256 == data + data - 256 < data - 1 < data
			//Send logic 1: Leave the bus alone
			//FIXME
			//Watch out for collisions 
		}else{
			//Send logic 0: Short the bus
			PORT${member["tx"]["port"]} |= (1<<${member["tx"]["pin"]});
			_delay_us(35); // Pulse duration -- 560 cycles
			PORT${member["tx"]["port"]} &= ~(1<<${member["tx"]["pin"]});
			//FIXME
			//Watch out for collisions 
		}
		data = nd;
	}
	return 0;
}

unsigned char ${modulevar("frame")}_send_frame(void){

	//Send frame header
	${modulevar("checksum")} = 0;
	${modulevar("state")} = 1;
	iso14543_3_6_frame* f = &${modulevar("frame")};
	unsigned char len = 0;
	unsigned char e = 0;

	if(e = iso14543_send(f->ctrl))
		return e;

	if(!f->ctrl.poll ){
		if( !f->ctrl.ft ){ //Extended frame
			iso14543_send(f->ctrle);
			len = f->aux.ext.len;
		}else{
			len = f->aux.std.len;
		}
	}
	for(unsigned char *i= &(f->sa); i < &(f->payload)+len; i++){
		if(e = iso14543_send(*i))
			return e;
	}
	${modulevar("checksum")} ^= 0xFF; //invert
	if(e = iso14543_send(${modulevar("checksum")}))
		return e;
	//Send status (yes, this is blocking.) 
	return 0;
}

void ${modulevar("frame")}_set_action (void){
}

