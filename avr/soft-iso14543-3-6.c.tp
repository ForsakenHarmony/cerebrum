
#ifndef _SOFT_ISO14543_3_6_
#define _SOFT_ISO14543_3_6_

//Structure of a iso14543-3-6 TP1 standard, extended and poll frame
typedef struct {
	unsigned char seqnum;
	//I kind of hate the person concocting this control field. On the other hand, it is probably the result of the work (I won't say collaboration) of a number of persons equal to the population of a small country.
	struct ctrl {				//Control field, always the first byte
		unsigned char ft:1;			//Frame type: 0 - extended/poll; 1 - standard
		unsigned char poll: 1;		//Poll frame - 1; otherwise 0
									//ft/poll are used in ack frames as follows: ack/busy 11, nack/nack+busy 00
		unsigned char r: 1;			//Repeat flag: 0 - repeated frame/ack frame; 1 - not repeated frame/poll frame
		unsigned char ack: 1;		//Ack frame - 0; otherwise 1
		unsigned char priority: 2;	//Priority: system/poll 0, urgent 2, normal 1, low 3
									// if this is an ack frame: ack/nack 3, busy/nack+busy 0
		unsigned char _: 2;			//Padding, always 00
	}; //1 byte
	struct ctrle {				//Extended control field (only present in -- you guessed it, extended frames)
		unsigned char at:1;			//Destination address type: physical/individual - 0; group - 1
		unsigned char hops:3;		//Hop count
		unsigned char eff:4;		//Extended frame format: default 0, LTE-HEE extended address type 01xx
	}; //1 byte
	union sa {					//Source address
		unsigned int i16;
		struct phy {				//Physical address
			unsigned char area:4;		//Area
			unsigned char line:4;		//Line
			unsigned char device;		//Device
		};
	}; //1 word
	union da {					//Destination address
		unsigned int group;			//Group/poll group address
		struct phy {				//Physical address
			unsigned char area:4;		//Area
			unsigned char line:4;		//Line
			unsigned char device;		//Device
		};
	}; //1 word
	union aux {					//Various flags
		struct std {				//Standard frame
			unsigned char at:1;			//Destination address type: physical/individual - 0; group - 1
			unsigned char hops:3;		//Hop count
			unsigned char len:4;		//Payload length
		};
		struct ext {				//Extended frame
			unsigned char len;			//Payload length (0xFF is an escape code)
		};
		struct poll {				//Poll frame
			unsigned char _:4;			//Padding (0000)
			unsigned char len:4;		//Number of poll responses expected
		};
	}; //1 byte
	unsigned char payload[255];
	unsigned char checksum;		//xor all bytes of the frame, invert.
} iso14543_3_6_frame;

#endif//_SOFT_ISO14543_3_6_

${modulevar("frame", "iso14543_3_6_frame", "BBHHB255sB", set_action=modulevar("frame")+"_set_action");

unsigned char ${modulevar("status")} = 0;
unsigned char ${modulevar("checksum")} = 0;

void ${init_function()} (void){
	DDR${member["tx"]["port"]} |= (1<<${member["tx"]["pin"]});
	//set up pin change interrupt
}

//add pin change interrupt vector

//XXX This module uses pin change interrupts since the pulses it tries to detect are only 34Âµs long (@16MHz ~= 512 cycles)
//XXX This module uses one 16-bit timer
//The timer is clocked with a 16934400Hz system clock overflows every 588 cycles. A bit is over every 1764 cycles.
//The error of this timing is less than 1% compared to a 9600Bd reference.

//Returns 0 on success, other stuff when an error occurs.
char iso14543_send_next_bit(unsigned char data){
	static unsigned char i = 0;
	static unsigned char nd = 0;
	if(i == 0){
		${modulevar("checksum")} ^= data;
		nd = data;
	}
	data = nd;
	nd = nd << 1;
	if(nd < data){ //ft bit set
		// i.e. (data * 2) mod 256 < data
		// unsigned char => 0 < data < 256
		// data < 128:
		//   data * 2 < data => false
		// data >= 128:
		//   data * 2 - 256 == data + data - 256 < data - 1 < data
		//Send logic 1: Leave the bus alone
		//FIXME Watch out for collisions 
	}else{
		//Send logic 0: Short the bus
		PORT${member["tx"]["port"]} |= (1<<${member["tx"]["pin"]});
		//FIXME Watch out for collisions 
	}
	data = nd;
	i++;
	if(i == 8){
		i = 0;
		return 1;
	}
	return 0;
}

unsigned char ${modulevar("frame")}_send_next_frame_bit(void){
	static unsigned char state = 0;
	static unsigned char* pos = 0;
	static unsigned char len = 0;
	iso14543_3_6_frame* f = &${modulevar("frame")};
	unsigned char e = 0;

	switch(state){
		//Send frame header
		case 0:
		${modulevar("checksum")} = 0;
		${modulevar("state")} = 1;
		len = 0;
		state = 1;
		//This is supposed to fall through
		case 1:
		if(e = iso14543_send_next_bit(f->ctrl)){
			if(e == 1){
				state++;
			}else{
				return e;
			}
		}
		break;
		case 2:
		if(!f->ctrl.poll ){
			if( !f->ctrl.ft ){ //Extended frame
				iso14543_send(f->ctrle);
				len = f->aux.ext.len;
			}else{
				len = f->aux.std.len;
			}
		}
		pos = &(f->sa);
		state = 3;
		//This is supposed to fall through
		case 3:
		if(e = iso14543_send_next_bit(*i)){
			if(e == 1){
				if(i < &(f->payload)+len){
					i++;
				}else{
					state = 4;
				}
			}else{
				return e;
			}
		}
		break;
		case 4:
		${modulevar("checksum")} ^= 0xFF; //invert
		//This is supposed to fall through
		state = 5;
		case 5:
		if(e = iso14543_send_next_bit(${modulevar("checksum")})){
			if(e == 1){
				//Send status (yes, this is blocking from a python lib point of view.) 
				state = 0;
				${modulevar("state")} = 0;
				return 0;
			}else{
				return e;
			}
		}
		break;
	}
	return 1;
}

ISR(/*FIXME*/){
	static unsigned char cnt = 0;
	cnt++;
	if(cnt == 3){
		cnt = 0;
		${modulevar("frame")}_send_next_frame_bit();
	}else{
		PORT${member["tx"]["port"]} &= ~(1<<${member["tx"]["pin"]});
	}
}

void ${modulevar("frame")}_set_action (void){
	${modulevar("state")} = 0;
}

