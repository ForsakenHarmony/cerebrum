/*
 Copyright (C) 2012 jaseg <s@jaseg.de>

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 version 3 as published by the Free Software Foundation.
 */

#include <avr/io.h>

void ${init_function()} (void){
% if device["pwm"].get(member["port"]+str(member["pin"])):
	${device["pwm"].get(member["port"]+str(member["pin"]))[1]}
% endif
% if device["adc"].get(member["port"]+str(member["pin"])):
	ADMUX |= REFS0 | ADLAR;
	ADCSRA |= ADEN | device["adc"]["prescaler_bits"];
% endif
}

//${modulevar("state", None, "B")}
void callback_set_${modulevar("state")} (uint16_t payload_offset, uint16_t argsize, uint8_t* args){
	PORT${member["port"]} &= ~(1<<${member["pin"]});
	if(args[0])
		PORT${member["port"]} |= (1<<${member["pin"]});
	uart_putc(0x00);
	uart_putc(0x00);
}

void callback_get_${modulevar("state")} (uint16_t payload_offset, uint16_t argsize, uint8_t* args){
	uart_putc(0x00);
	uart_putc(0x01);
	uart_putc(!!(PIN${member["port"]} & (1<<${member["pin"]})));
}

//${modulevar("direction", None, "B")}
void callback_set_${modulevar("direction")} (uint16_t payload_offset, uint16_t argsize, uint8_t* args){
	DDR${member["port"]} &= ~(1<<${member["pin"]});
	if(args[0])
		DDR${member["port"]} |= (1<<${member["pin"]});
	uart_putc(0x00);
	uart_putc(0x00);
}

void callback_get_${modulevar("direction")} (uint16_t payload_offset, uint16_t argsize, uint8_t* args){
	uart_putc(0x00);
	uart_putc(0x01);
	uart_putc(!!(DDR${member["port"]} & (1<<${member["pin"]})));
}

% if device["adc"].get(member["port"]+str(member["pin"])):
//${modulevar("analog", None, "B")}
void callback_get_${modulevar("analog")} (uint16_t payload_offset, uint16_t argsize, uint8_t* args){
	uart_putc(0x00);
	uart_putc(0x01);
#if defined(__AVR_ATmega48__) ||defined(__AVR_ATmega88__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega48P__) || defined(__AVR_ATmega88P__) || defined(__AVR_ATmega168P__) || defined(__AVR_ATmega328P__)
	ADMUX &= 0xF0;
	ADMUX |= ${device["adc"].get(member["port"]+str(member["pin"]))};
#elif defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1280__)  || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega640__)
	ADMUX &= 0xE0;
	ADCSRB &= 0xF7;
	ADMUX |= ${device["adc"].get(member["port"]+str(member["pin"]))}&0x1F;
	ADCSRB |= ${device["adc"].get(member["port"]+str(member["pin"]))}&0x20>>2;
#endif
	while(!(ADCSRA&(1<<ADIF))); //wait for conversion to finish
	putc_escaped(ADCH);
	ADCSRA |= (1<<ADIF); //reset the interrupt flag
}
% endif

% if device["pwm"].get(member["port"]+str(member["pin"])):
//${modulevar("pwm", None, "B")}
void callback_set_${modulevar("pwm")} (uint16_t payload_offset, uint16_t argsize, uint8_t* args){
	OCR${device["pwm"].get(member["port"]+str(member["pin"]))[0]} = args[0];
	uart_putc(0x00);
	uart_putc(0x00);
}

void callback_get_${modulevar("pwm")} (uint16_t payload_offset, uint16_t argsize, uint8_t* args){
	uart_putc(0x00);
	uart_putc(0x01);
	putc_escaped(OCR${device["pwm"].get(member["port"]+str(member["pin"]))[0]});
}
% endif

