/*
 Copyright (C) 2012 jaseg <s@jaseg.de>

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 version 3 as published by the Free Software Foundation.
 */

#include <avr/io.h>

void ${init_function()} (){
% if member.get("timer_reg"):
	${member["timer_reg"]} |= ${member["timer_flags"]};
% endif
% if member.get("adc_chsel"):
	//FIXME this ought to be more device-independent.
	//add device configs as in ethersex or would that be over-engineering?
	ADMUX |= REFS0 | ADLAR;
	ADCSRA |= ADEN | ADSC | ADFR | ADPS2 | ADPS1 | ADPS0;
% endif
}

//${modulevar("state", None, "B")}
void callback_set_${modulevar("state")} (uint16_t argsize, uint8_t* args){
	PORT${member["port"]} &= ~(1<<${member["pin"]});
	if(args[0])
		PORT${member["port"]} |= (1<<${member["pin"]});
	uart_putc(0x00);
	uart_putc(0x00);
	uart_putc(0x00);
	uart_putc(0x00);
}

void callback_get_${modulevar("state")} (uint16_t argsize, uint8_t* args){
	uart_putc(0x00);
	uart_putc(0x01);
	uart_putc(!!(PIN${member["port"]} & (1<<${member["pin"]})));
	uart_putc(0x00);
	uart_putc(0x00);
}

//${modulevar("direction", None, "B")}
void callback_set_${modulevar("direction")} (uint16_t argsize, uint8_t* args){
	DDR${member["port"]} &= ~(1<<${member["pin"]});
	if(args[0])
		DDR${member["port"]} |= (1<<${member["pin"]});
	uart_putc(0x00);
	uart_putc(0x00);
	uart_putc(0x00);
	uart_putc(0x00);
}

void callback_get_${modulevar("direction")} (uint16_t argsize, uint8_t* args){
	uart_putc(0x00);
	uart_putc(0x01);
	uart_putc(!!(DDR${member["port"]} & (1<<${member["pin"]})));
	uart_putc(0x00);
	uart_putc(0x00);
}

% if member.get("adc_chsel"):
//${modulevar("analog", None, "B")}
void callback_get_${modulevar("analog")} (uint16_t argsize, uint8_t* args){
	uart_putc(0x00);
	uart_putc(0x01);
	ADMUX &= 0xF0;
	ADMUX |= ${module["adc_chsel"]};
	uart_putc(0x00);
	uart_putc(0x00);
}
% endif

% if member.get("pwm_reg"):
//${modulevar("pwm", None, "B")}
void callback_set_${modulevar("pwm")} (uint16_t argsize, uint8_t* args){
	${member["pwm_reg"]} = args[0]'
	uart_putc(0x00);
	uart_putc(0x00);
	uart_putc(0x00);
	uart_putc(0x00);
}

void callback_get_${modulevar("pwm")} (uint16_t argsize, uint8_t* args){
	uart_putc(0x00);
	uart_putc(0x01);
	uart_putc(${member["pwm_reg"]});
	uart_putc(0x00);
	uart_putc(0x00);
}
% endif

