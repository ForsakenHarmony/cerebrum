
import subprocess
import os.path
import struct
from mako.template import Template
from datetime import datetime
import binascii
import json
import pylzma
import codecs

autocode_stub = """\
/* AUTOGENERATED CODE FOLLOWS!
 * This file contains the code generated from the module templates as well as
 * some glue logic. It is generated following the device config by "generate.py"
 * in this very folder. Please refrain from modifying it, modify the templates
 * and generation logic instead.
 * 
 * Device name: ${devname}, build version: ${version}, build date: ${builddate}
 */

#include <string.h>
#include "autocode.h"
#include "comm.h"
"""

autoglue = """
#include "config.h"

comm_callback comm_callbacks[] = {
	% for (callback, id) in callbacks:
	&${callback}, //${id}
	% endfor
};

void init_auto(){
	% for initfunc in init_functions:
		${initfunc}();
	%endfor
}

void loop_auto(){
	% for loopfunc in loop_functions:
		${loopfunc}();
	%endfor
}

void callback_get_descriptor_auto(uint16_t alen, uint8_t* argbuf){
	//FIXME
	putc_escaped(auto_config_descriptor_length >> 8);
	putc_escaped(auto_config_descriptor_length & 0xFF);
	for(char* i=auto_config_descriptor; i < auto_config_descriptor+auto_config_descriptor_length; i++){
		putc_escaped(*i);
	}
	//FIXME add crc generation
	putc_escaped(0x00);
	putc_escaped(0x00);
}

"""

accessor_callbacks = """
void callback_set_${name}(uint16_t alen, uint8_t* argbuf){
	if(! sizeof(${ctype}) == alen){
		//FIXME error handling
		return;
	}
	memcpy(&${name}, argbuf, sizeof(${ctype}));
}

void callback_get_${name}(uint16_t alen, uint8_t* argbuf){
	if(! alen == 0){
		//FIXME error handling
		return;
	}
	putc_escaped(sizeof(${ctype})>>8);
	putc_escaped(sizeof(${ctype})&0xFF);
	for(char* i=((char*)&${name}); i<((char*)&${name})+sizeof(${ctype}); i++){
		putc_escaped(*i);
	}
	//FIXME add crc generation
	putc_escaped(0x00);
	putc_escaped(0x00);
}

"""

config_c_template = """\
/* AUTOGENERATED CODE AHEAD!
 * This file contains the device configuration in lzma-ed json-format. It is
 * autogenerated by "generate.py" (which should be found in this folder).
 */
#include "config.h"
unsigned int auto_config_descriptor_length = ${desc_len};
char auto_config_descriptor[] = {${desc}};
"""

def generate(dev, devicename):
	members = dev["members"]
	seqnum = 23
	current_id = 0
	builddate = datetime.now()
	dev["builddate"] = str(builddate)
	autocode = Template(autocode_stub).render_unicode(devname=devicename, version=dev["version"], builddate=builddate)
	init_functions = []
	loop_functions = []
	
	callbacks = []
	def register_callback(name):
		nonlocal current_id
		callbacks.append((name, current_id))
		current_id += 1

	register_callback("callback_get_descriptor_auto")

	def generate_accessors(name, ctype):
		return Template(accessor_callbacks).render_unicode(name=name, ctype=ctype);

	for mname, member in members.items():
		mfile = member["type"]
		mtype = mfile.replace('-', '_')
		typepath = os.path.join(os.path.dirname(__file__), mfile + ".c.tp")
#		 if not os.path.exists(typepath):
#			 print("Cannot find a handler for member type " + dev["type"])
#			 exit(1)

		init_function = "init_{}_{}".format(mtype, seqnum)
		init_functions.append(init_function)
		loop_function = "loop_{}_{}".format(mtype, seqnum)
		loop_functions.append(loop_function)

		member["properties"] = {}
		member["functions"] = {}
		accessors = ""

		def modulevar(name, ctype=None, fmt=None):
			varname = "modvar_{}_{}_{}".format(mtype, seqnum, name)
			if fmt is not None and ctype is not None:
				nonlocal accessors
				accessors += generate_accessors(varname, ctype)

				register_callback("callback_get_" + varname)
				member["properties"][name] = {
						"size": struct.calcsize(fmt),
						"id": current_id,
						"format": fmt}
				register_callback("callback_set_" + varname)
				return "{} {}".format(ctype, varname)

			return varname

		def module_callback(name, argformat="", retformat=""):
			cbname = "callback_{}_{}_{}".format(mtype, seqnum, name)
			register_callback(cbname)
			member["functions"][name] = {
					"id": current_id,
					"args": argformat,
					"returns": retformat}
			return cbname

		seqnum += 1
		tp = Template(filename=typepath)
		autocode += tp.render_unicode(
				init_function=init_function,
				loop_function=loop_function,
				modulevar=modulevar,
				module_callback=module_callback,
				dev=dev)
		autocode += accessors

	autocode += Template(autoglue).render_unicode(init_functions=init_functions, loop_functions=loop_functions, callbacks=callbacks)
	with open(os.path.join(os.path.dirname(__file__), "autocode.c"), "w") as f:
		f.write(autocode)
	subprocess.call(["/usr/bin/env", "make", "-C", os.path.dirname(__file__), "clean", "all"])
	config = pylzma.compress(json.JSONEncoder(separators=(',',':')).encode(dev))
	with open(os.path.join(os.path.dirname(__file__), "config.c"), "w") as f:
		f.write(Template(config_c_template).render_unicode(desc_len=len(config), desc=",".join(map(str, config))))
	return dev

def commit(dev):
	make_env = os.environ.copy()
	make_env["SERIAL"] = dev["location"] # "location" contains the launchpad's USB serial number
	subprocess.call(["/usr/bin/env", "make", "-C", os.path.dirname(__file__), "program"], env=make_env)

